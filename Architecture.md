# 4.1 엔진 아키텍처
>MySQL 서버는 사용자 입장에서 보면 거의 차이가 없지만 다른 DBMS 에 비해 구조가 독특한데 이로인해 얻을수 있는 이점과 문제점이 있다.

## 4.1.1 MySQL 의 전체 구조

![](https://velog.velcdn.com/images/cmong0516/post/307692bc-e760-4a81-b262-16880efb1112/image.png)

> MySQL 은 일반 상용 RDMBS 와 같이 대부분의 프로그래밍 언어로부터의 접근 방법을 모두 지원한다.
MySQL 서버는 **MySQL엔진**과 **스토리지 엔진**으로 크게 구분할수 있다.

### 4.1.1.1 MySQL 엔진
> MySQL 엔진의 구성
- **커넥션 핸들러 (클라이언트의 접속)**
- **SQL 파서(쿼리 요청 처리)**
- **옵티마이저(쿼리 최적화)**

### 4.1.1.2 스토리지 엔진
> MySQL 엔진은 요청된 SQL 문장을 분석하거나 최적화 하는등 두뇌에 해당하는 처리를 수행하고 실제 데이터를 저장하거나 읽어오는 부분은 스토리지 엔진이 담당한다.
**MySQL 서버의 MySQL 엔진은 하나지만 스토리지 엔진은 여러개를 사용할수 있다.**

### 4.1.1.3 핸들러 API
> MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할때 각 스토리지 엔진에 이를 요청하는데 이때 요청을 핸들러 요청 이라 하고 여기서 사용되는 API를 핸들러 API 라고한다.
InnoDB 스토리지 엔진은 이 핸들러 API를 이용해서 MySQL 엔진과 데이터를 주고받는다.
핸들러 API의 데이터 작업 확인 : show global status like 'handler%';

## 4.1.2 스레딩 구조
> MySQL 서버는프로세스 기반이 아니라 스레드 기반으로 작동하며 크게 **포그라운드 스레드**와 **백그라운드 스레드**로 구분할수 있다.
실행중인 스레드 확인
- select thread_id,name,type,processlist_user,processlist_host from performance_schema.threads order by type , thread_id;
- 44 개의 스레드가 실행중인데 이중 3개가 포그라운드 스레드로 표시되는데 thread/sql/one_connection 스레드만 실제 사용자의 요청을 처리하는 포그라운드 스레드이다.

### 4.1.2.1 포그라운드 스레드
>- 포그라운드 스레드는 최소한 MySQL 서버에 접속된 클라이언트 수만큼 존재한다.
- 클라리언트가 작업을 마치고 커넥션을 종료함녀 해당 커넥션을 담당하던 포그라운드 스레드는 스레드캐시로 돌아간다.이때 스레드 캐시에 일정 개수 이상의 대기중인 스레드가 있으면 스레드 캐시에 넣지 않고 스레드를 종료시켜 일정 개수의 스레드만 스레드 캐시에 존재하게 되는데 이때 스레드 캐시에 유지할수 있는 최대 스레드 개수는 thread_cache_size 시스템 변수로 설정한다.
- 포그라운드 스레드는 데이터를 MySQL 의 데이터 버퍼나 캐시에서 가져오며 버퍼나 캐시에 없는경우는 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와 처리한다.

### 4.1.2.2 백그라운드 스레드
>- 인서트 버퍼를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어노는 스레드
- 잠금이나 데드락을 모니터링 하는 스레드

>가장 중요한 역할은 로그 스레드와 버퍼 데이터를 디스크로 내려쓰는 작업을 처리하는 쓰기 쓰레드이다.
InnoDB 에서도 데이터를 읽는 작업은 주로 클라이언트 스레드에서 처리되기 때문에 읽기 스레드는 많이 설정할 필요가 없지만 쓰기 스레드는 아주 많은 작업을 백그라운드로 처리하기 때문에 2~4 정도, DAS , SAN 을 사용할 때는 디스크를 최적으로 사용할수 있을만큼 충분히 설정한다.

>사용자의 요청을 처리하는 도중 데이터의 쓰기 작업은 지연되어 처리될수 있지만 데이터 읽기 작업은 절대 지연될수 없다. 그래서 일반적인 DBMS 에는 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 탑재되어 있다.
하지만 MyISAM 은 사용자 스레드가 쓰기 작업까지 함께 처리하도록 설계되어 있다.
따라서 InnoDB 에서는 insert, update, delete 쿼리로 데이터가 변경되는 경우 데이터가 디스크의 데이터 파일로 완전히 저장될때까찌 기다리지 않아도 된다.


## 4.1.3 메모리 할당 및 사용구조
>- 글로벌 메모리 영역
- 로컬 메로리 영역

### 4.1.3.1 글로벌 메모리 영역
> 일반적으로 클라이언트 스레드 수와 무관하게 하나의 메모리 공간만 할당되며 생성된 글로별 영역의 개수에 상관없이 모든 스레드에 공유된다.
- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

#### InnoDB란 ?
> InnoDB 란 MySQL 을 위한 데이터베이스 엔진이다.

#### 데이터베이스 엔진이란 ?
> - 데이터베이스 엔진은 DBMS 가 데이터베이스 데이터를 crud 할때 사용하는 기본 소프트웨어 컴포넌트이다.

### 4.1.3.2 로컬 메모리 영역
>- 세션 메모리 영역 이라고도 표현하며 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역이다.
- 대표적으로 커넥션 버퍼 , 정렬 버퍼 등이 있다.
- 클라이언트가 MySQL 서버에 접속하면 서버는 클라이언트의 커넥션 요청을 처리하기 위해 커넥션을 할당하는데 클라이언트 스레드가 사용하는 메모리 공간이라고 해서 클라이언트 메모리 영역 이라고도 한다. (커넥션을 세션 이라고도 하기 때문에 세션 메모리 영역 이라고도 함)
- 각 클라이언트 스레드에 독립적으로 할당되며 절대 공유되어 지지 않는다.

#### 대표적인 로컬 메모리 영역
>- 정렬버퍼
- 조인버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼
