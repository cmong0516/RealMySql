# 5.1 트랜잭션

## 5.1.1 MySQL 에서의 트랜잭션
> - 트랜잭션은 꼭 여러개의 변경 작업을 수행하는 퀄가 조합되었을때만을 의미하는 개념은 아니다.
- 트랜잭션은 하나의 논리적인 작업 셋에 몇개의 쿼리가 있던 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용디지 않아야 함을 보장해주는것.
1. create table tab_myisam (fdpk int not null , primary key (fdpk)) engine=MyISAM;
2. insert into tab_myisam (fdpk) values (3);
3. create table tab_innodb (fdpk int not null, primary key (fdpk)) engine=innodb;
4. insert into tab_innodb(fdpk) values(3);
5. set autocommit=on;
6. insert into tab_myisam(fdpk) values (1),(2),(3);
7. insert into tab_innodb(fdpk) values (1),(2),(3);
- 실행시 6,7 번 모두 프라이머리 키 중복 오류로 쿼리가 실패하는데 레코드를 조회해 보면 1,2,3 밸류를 추가하는 쿼리에서 오류가 발생했지만 tab_myisam 테이블에는 1,2,3 값이 들어있는데 1, 2 를 저장하고 3을 저장하려고 할때 에러가 발생한것인데 이미 추가된 1,2 는 저장된채로 놔두고 쿼리 실행을 종료했다.(부분 업데이트)
- tab_innodb 를 조회해보면 같은 쿼리를 실행했음에도 1,2 값은 없고 3 값만 저장되어있다. 쿼리 실행 과정에 에러가 발생하여 전체 데이터를 모두 추가하지 않은것.

## 5.1.2 주의사항
>1. 처리시작
>> 데이터베이스 커넥션 생성
트랜잭션 시작
2. 사용자의 로그인 여부 확인
3. 사용자의 글쓰기 내용의 오류 여부 확인
4. 첨부로 업로드된 파일 확인 및 저장
5. 사용자의 입력 내용을 저장
6. 첨부 파일 정보를 저장
7. 저장된 내용 또는 기타 정보를 조회
8. 게시물 등록에 대한 알림 메일 발송
9. 알림 메일 발송 이력을 저장
>>트랜잭션 종료
데이터베이스 커넥션 반납
10. 처리 완료

>- 1,2 사이에에서 커넥션을 생성하고 9,10 사이에서 트랜잭션을 커밋하고 커넥션을 종료하게 일반적으로 구현하지만 실제로 데이터를 저장하는 작업은 5번부터 시작되므로 2,3,4 과정은 트랜잭션에 포함시킬 필요는 없다.
- 메일 전송이나 FTP 파일 전송 작업 또는 네트워크를 통해 원격 서버와 통신하는 작업을 실행하다 에러가 발생할 경우 웹서버 뿐만 아니라 DBMS 서버까지 위험해질수 있기에 트랜잭션 내에서 제거하는것이 좋다.

### 수정을 반영한 처리방법
>1. 처리시작
2. 사용자의 로그인 여부 확인
3. 사용자의 글쓰기 내용의 오류 여부 확인
4. 첨부로 업로드된 파일 확인 및 저장
>> 데이터베이스 커넥션 생성
트랜잭션 시작
5. 사용자의 입력 내용을 저장
6. 첨부 파일 정보를 저장
>>트랜잭션 종료
7. 저장된 내용 또는 기타 정보를 조회
8. 게시물 등록에 대한 알림 메일 발송
>>트랜잭션 시작
9. 알림 메일 발송 이력을 저장
>> 트랜잭션 종료
데이터베이스 커넥션 반납
10. 처리 완료

# 5.2 MySQL 엔진의 잠금
>- MySQL 에서 사용되는 잠금은 스토리지 엔진 레벨과 MySQL 서버에서 스토리지 엔진을 제외한 MySQL 엔진 레벨로 나뉜다.
- MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만 스토리지 엔진의 잠금은 스토리지 엔진간 영향을 미치지 않는다.

## 5.2.1 글로벌 락
>- 글로벌 락은 flush tables with read lock 명령으로 획득할수 있으며 MySQL 에서 제공하는 잠금중에 가장 범위가 크다.
- 락을 획득하면 다른 세션에서 select 를 제외한 대부분의 DDL , DML 문장이 락 해제시 까지 대기상태로 남는데 글로벌 락이 미치는 영향범위는 서버 전체이며 MyISAM ,메모리 테이블에 대해 mysqldump 로 일관된 백업을 받아야 할때 글로벌락을 사용한다.
- InnoDB 스토리지 엔진은 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 데이터 변경 작업을 멈출 필요가 없어서 8버전 이후 더 가벼운 글로벌 락의 필요성이 생겨 Xtrabackup Enterprise Backup 이 도입되었다.
- XtrapBackup 이나 Enterprise Backup 툴이 실행되는 도중에 스키마 변경이 실행되면 백업이 실패하게 되는데 MySQL 서버 의 백업 락은 이런경우 백업의 실패를 막기 위해 DDL 명령이 실행되면 복제를 일시중지 하는 역할을 한다.

## 5.2.2 테이블 락
> - 테이블 락은 개별 테이블 단위로 설정되는 잠금이며 특정 테이블 락을 획득할수 있다.
lock tables table_name [read | write]
- 명시적인 테이블 락은 글로벌 락과 동일하게 온라인 작업에 상당한 영향을 미치기에 거의 사용할 일이 없다.
- 묵시적 테이블 락은 MyISAM , 메모리 테이블에 데이터를 변경하는 쿼리를 실행하면 발생하는데 데이터가 변경되는 테이블에 잠금을 설정하고 데이터를 변경한후 즉시 잠금을 해제한다.
- InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에 단순 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되지 않는다
DML : X
DDL : O

## 5.2.3 네임드 락
> - 네임드 락은 get_lock() 함수를 이용해 임의의 문자열에 대해 잠금을 설정할수 있다.
- 이 잠금은 대상이 테이블이나 레코드 또는 AI 같은 데이터베이스 객체가 아니다.
- 데이터베이스 서버 1대에 5대의 웹 서버가 접속하는 상황에서 5대의 웹 서버가 어떤 정보를 동기화 해야 할경우 네임드 락으로 쉽게 해결할수 있다.
- 중첩 사용할수 있으며 현재 세션에서 획득한 네임드 락을 모두 해제하는 기능도 있다.

## 5.2.4 메타데이터 락
>- 메타데이터 락은 데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 잠금으로 명시적으로 획득하거나 해제할수 있는것이 아니고
rename table tab_a to tab_b 같이 테이블 이름을 변경하는 경우 자동으로 획득하는 잠금이다.
- rename table 명령의 경우 원본 이름과 변경될 이름 두개 모두 한번에 잠금을 설정한다.


# 5.3 InnoDB 스토리지 엔진 잠금
> - InnoDB 스토리지 엔진은 MySQL 에서 제공하는 잠금과 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있고 레코드 기반의 잠금 방식 때문에 MyISAM 보다 훨씬 뛰어나느 동시성 처리를 제공할수 있다.
- 이원화된 잠금 처리 탓에 InnoDB 스토리지 엔진에서 사용되는 잠금에 대한 정보는 MySQL 명령을 이용해 접근하기가 상당히 까다로웠는데 information_schema 데이터베이스에 존재하는 innodb_trx , innodb_locks , innodb_lock_waits 테이블을 조인해서 조회하면 현재 어떤 트랜잭션이 잠금을 대기하고 있고 해당 잠금을 어떤 트랜잭션이 가지고 있는지 확인할수 있고 장시간 잠금을 가지고 있는 클라이언트를 찾아서 종료시킬 수도 있다.

## 5.3.1 InnoDB 스토리지 엔진의 잠금
> - InnoDB 스토리지 엔진은 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락으로 또는 테이블 락으로 레벨업 되는 경우는 없다.
- InnoDB 스토리지 엔진에서는 레코드 락 뿐 아니라 레코드와 레코드 사이의 간격을 잠그는 갭락 이라는 것이 존재한다.

### 5.3.1.1 레코드 락
>- 레코드 자체만을 잠그는 것을 레코드락 이라고 하며 InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다.
인덱스가 없는 테이블이라면 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.

### 5.3.1.2 갭 락
>- 갭 락은 레코드 자체가 아니라 레코드와 인접한 레코드 사이의 간격만을 잠그는 것
- 갭 락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어하는 것으로 갭락 자체보다 넥스트 키 락의 일부로 자주 사용된다.

### 5.3.1.3 넥스트 키 락
>- 레코드 락과 갭 락을 합쳐놓은 형태의 잠금을 넥스트 키 락 이라고 한다.
- innodb_locks_unsage_for_binlog 시스템 변수가 (0으로 설정) 비활성 되면 변경을 위해 검색하는 레코드에는 넥스트 키 락 방식으로 잠금이 걸린다.
- InnoDB 의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될때 소스 서버에서 만들어낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적이다.
- 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션이 기다리는 상황이 자주 발생하는데 가능하다면 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.

### 5.3.1.4 자동 증가 락
>- MySQL 에서는 자동 증가하는 숫자 값을 추출하기 위해 AI 라는 칼럼 속성을 제공하는데 AI 칼럼이 사용된 테이블에 동시에 여러 레코드가 insert 되는 경우 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야 하는데 InnoDB 스토리지 엔진에서 이를 위해 내부적으로 AI 락 이라고 하는 테이블 수준의 잠금을 사용한다.
- AI 락은 insert replace 쿼리와 같이 새로운 레코드를 저장하는 쿼리에서만 필요하고 트랜잭션 관계없이 insert , replace 문장에서 AI 값을 가져오는 순간만 락이 걸렸다가 즉시 해제된다.

## 5.3.2 인덱스와 잠금
>- InnoDB 의 잠금과 인덱스는 상당히 중요한 연관관계가 있는데 InnoDB 의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식이라고 위에 언급했었다.
- update 쿼리를 실행하는데 그 테이블에 인덱스가 없다면 테이블을 풀 스캔하면서 update 작업을 하게 되며 모든 레코드를 잠금하게 된다.
- 따라서 MySQL 의 InnoDB 에서 인덱스 설게는 매우 중요하다.

## 5.3.3 레코드 수준의 잠금 확인 및 해제
>- InnoDB 스토리지 엔진을 사용하는 테이블의 레코드 수준 잠금은 테이블 수준의 잠금보다는 조금 더 복잡한데 테이블 잠금에서는 잠금의 대상이 테이블 자체이므로 수비게 문제의 원인이 발견되고 해결될수 있지만 레코드 수준의 잠금은 테이브르이 레코드 각각에 잠금이 걸리므로 그 레코드가 자주 사용되지 않는다면 오랜시간 잠금 상태로 남아도 잘 발견되지 않는다.
- 강제로 잠금을 해제하려면 Kill 명령어로 MySQL 서버의 프로세스를 강제종료 시킨다.
